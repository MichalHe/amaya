from __future__ import annotations
from dataclasses import dataclass
from typing import (
    Dict,
    List,
    Set,
    Any,
    Tuple,
    Generator,
    Union,
    Optional
)
from utils import number_to_bit_tuple
from relations_structures import Relation


LSBF_AlphabetSymbol = Tuple[Union[int, str], ...]


@dataclass
class LSBF_Alphabet():
    variable_names: Dict[int, str]
    variable_numbers: List[int]
    active_variables: Set[str]
    active_symbols: Optional[Tuple[LSBF_AlphabetSymbol, ...]] = None

    @staticmethod
    def from_inequation(relation: Relation) -> LSBF_Alphabet:
        """
        Creates a alphabet from given relation.

        The set of symbols in the created alphabet are explicitely instantiated. The symbols
        contain do not care bit '*' on tracks corresponding to variables whos coeficients 
        are zero.

        The alphabet does not have variable names set, only variables ids that are generated by
        enumeration of the variable names.

        Warning:
            This function should not be called anymore as it works with variable names, which 
            are ambiguous.

        :param relation: Relation from which the variables will be extracted and the alphabet will be created.
        :returns: Alphabet for variables in the given relation.
        """
        act_symbols, _ = LSBF_Alphabet.generate_compressed_symbols(relation.variable_coeficients)

        active_variables = [var for i, var in enumerate(relation.variable_names) if relation.variable_coeficients[i] != 0]
        variable_ids = list(range(1, len(active_variables) + 1))
        return LSBF_Alphabet(variable_names={},
                             variable_numbers=variable_ids,
                             active_variables=set(active_variables),
                             active_symbols=act_symbols)

    def gen_projection_symbols_onto_variables(self, variables_subset: List[int]) -> Generator[Tuple[int, ...], Any, Any]:
        """
        Generate alphabet symbols of an alphabet for the variables_subset.
        """
        # We actually do not care about the subset passed in, we just generate
        # bit vectors of given length
        symbol_size = len(variables_subset)
        for i in range(2**len(variables_subset)):
            bit_vector = number_to_bit_tuple(i, tuple_size=symbol_size)
            yield bit_vector

    def cylindrify_symbol_of_projected_alphabet(self,
                                                variables: List[int],
                                                symbol: Tuple[int, ...]) -> Tuple[Union[str, int], ...]:
        """
        Cylindrify the given symbol of an alphabet with given variables. 

        Performs cylindrification on the given symbol that belongs to a smaller alphabet for a subset of variables
        of this alphabet.
        :param variables: A list of variables (ids) identifying the tracks of the symbol.
                          The ids needs to be sorted. 
        :param symbol: Symbol with bits containing the values of `variables` tracks.
                       The symbol should contain 0/1/* for bit values, but this is not checked.
        :returns: The cylindrified symbol that belongs to this alphabet with don't care bits on tracks whose 
                  variables are not in `variables`.  
        """
        alphabet_size = len(self.variable_numbers)

        # Create a list of indices where we should put the values from the
        # provided symbol (rest will be '*')
        vi = 0  # Index of the next variable name in provided variables to be checked
        used_variables_cooficients = []
        for i, var_id in enumerate(self.variable_numbers):
            if var_id == variables[vi]:
                used_variables_cooficients.append(i)
                vi += 1

            if vi == len(variables):
                break

        ni = 0  # Index to the next bit in the given symbol that should be used.
        cylindrified_symbol: List = [None] * alphabet_size
        for i in range(alphabet_size):
            if i == used_variables_cooficients[ni]:
                cylindrified_symbol[i] = symbol[ni]
                ni += 1
                # All bits from the given symbol have been used, fill the rest
                # with *.
                if ni == len(symbol):
                    for j in range(i+1, alphabet_size):
                        cylindrified_symbol[j] = '*'
                    break
            else:
                cylindrified_symbol[i] = '*'
        return tuple(cylindrified_symbol)

    @staticmethod
    def generate_compressed_symbols(coefs: List[int]) -> Tuple[List[LSBF_AlphabetSymbol], List[LSBF_AlphabetSymbol]]:
        """
        Generate alphabet symbols to variables with given coeficients.

        Generate symbols for variable coeficients with don't care bit '*' in place of 
        zero variable coeficients (that is what is meant by compressed).
        """
        nonzero_coefs_pos = [i for i, coef in enumerate(coefs) if coef != 0]
        nonzero_coefs_cnt = len(nonzero_coefs_pos)

        total_coefs_cnt = len(coefs)
        if nonzero_coefs_cnt == 0:
            symbols = [tuple(['*'] * total_coefs_cnt)]
            return [], symbols  # Active symbols are empty

        act_symbols = []
        symbols = []
        for i in range(2**nonzero_coefs_cnt):
            bits = number_to_bit_tuple(i, tuple_size=nonzero_coefs_cnt)

            ni = 0  # Index to the next nonused nonzero coef index
            symbol: List = [None] * total_coefs_cnt
            for i in range(total_coefs_cnt):
                if i == nonzero_coefs_pos[ni]:
                    symbol[i] = bits[ni]
                    ni += 1
                    # All nonzero coefs have been used, do the rest.
                    if ni == nonzero_coefs_cnt:
                        for j in range(i+1, total_coefs_cnt):
                            symbol[j] = '*'
                        break
                else:
                    symbol[i] = '*'

            act_symbols.append(bits)
            symbols.append(tuple(symbol))
        return act_symbols, symbols

    @staticmethod
    def from_variable_names(variable_names: Tuple[str, ...]) -> LSBF_Alphabet:
        variable_numbers = list(map(
            lambda index: index + 1,
            range(len(variable_names))))

        return LSBF_Alphabet(
            active_variables=set(variable_names),
            variable_names={},
            variable_numbers=variable_numbers
        )

    @staticmethod
    def from_variable_ids(variable_ids: List[int]) -> LSBF_Alphabet:
        '''Creates a new alphabet from the given variable_name, id pairs.
        The variables list should be sorted by the ID.
        '''
        variable_names: Dict[int, str] = dict()
        variable_ids = sorted(variable_ids)

        return LSBF_Alphabet(
            active_variables=set(),
            variable_names=variable_names,
            variable_numbers=variable_ids
        )

    @property
    def symbols(self):
        letter_size = len(self.variable_numbers)
        for i in range(2**letter_size):
            yield number_to_bit_tuple(i, tuple_size=letter_size, pad=0)

    def bind_variable_name_to_id(self, variable_name: str, variable_id: int):
        self.variable_names[variable_id] = variable_name